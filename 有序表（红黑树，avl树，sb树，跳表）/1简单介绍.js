/*
 * @Author: your name
 * @Date: 2021-04-02 18:33:04
 * @LastEditTime: 2021-04-03 16:11:00
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \baseUp\有序表\1简单介绍.js
 */

// java中有序表用红黑树实现

// 哈希表的增删改查都是O(1)
// 有序表均为O(logN)

// 搜索二叉树删除结点
// 首先查找有无
// 若有，则分为四种情况
// ①删除的结点是叶子结点，直接删除即可
// ②删除的结点有右孩子没有左孩子，左孩子接替其环境（即左孩子移动到被删除的结点的位置）
// ③删除的结点有左孩子没有右孩子，右孩子接替其环境（即右孩子移动到被删除的结点的位置）
// ④既有左孩子又有右孩子，（使用左孩子的最右结点或者右孩子的最左节点代替即可）
// 同时右树的最左孩子的右孩子交给其父节点，作为其父节点的左孩子.




// AVL树
// avl树的平衡性要求最高，左子树和右子树的高度不能超过1
// avl树结点存储的信息：左孩子，右孩子，高度信息，父节点
// 有关平衡性的操作
// 左旋，右旋

// avl树不平衡的情况：
// ①LL型==>右旋
// ②RR型==>左旋
// ③LR型==>左子树的右链过长：先左旋...最后再右旋
// ④RL型==>右子树的左链过长：先右旋...最后左旋

// 检查平衡性：插入节点的时候，由该节点开始，依次向上检查子树的高度差，检查是否有以上四种违规(检查的时间复杂度O(1)，∵每个节点都有高度信息),
// 若有则进行调整(至多进行两次调整),调整代价O(logN)，调整完之后，继续向上检查

// 检查平衡性：删除节点的时，（删除节点同搜索二叉树的操作，删除之后在检查平衡性）
// ①若该节点位叶子节点，则依次向上检查父节点二叉树的平衡性（与加入结点类似）
// ②若该节点有左无右，或有右无左，其左孩子或者右孩子代替其环境之后，从删除的位置（被删除结点的位置）开始，依次向上检查其平衡性
// ③既有左又有右，其右子树的最左节点代替其环境之后，从右子树的最左结点的原先位置开始依次向上检查平衡性




// SB树（sizeBalanceTree）
//              a
//           /     \
//          b      c
//        /  \    /  \
//       d   e   f   g  
// 如图：b是f和g的叔叔结点，（b的侄子结点：其兄弟结点的孩子结点）兄弟节点定义为：e的兄弟节点为d，没有f和g、
// SB树需要满足的条件：一个叔叔结点（将其作为子树的跟，以其作为根节点的树的节点总数不能小于（≥）任何以其侄子结点作为根节点的子树的结点数量）
// 如果任何结点都做到了以上要求，则满足sb树的要求

// 违规类型：LL:b的结点总数大于了c的结点总数
// RR：g的结点总数大于了b
// LR：e的节点总数大于c
// RL：f的节点总数大于b

// 每个结点的违规情况最多只符合上述一种，原因：增加和删除结点的时候就检查平衡树的违规情况，不可能四种情况都满足（即结点是一个一个增加和删除的）

// 违规调整：
// LL:右旋，之后检查平衡性，见sb树文件夹
// RR;左旋.............................
// LR型：e的节点总数大于c，局部左旋，整体右旋，之后结点发生变化的结点调用m函

// 增加节点平衡性调整：从该结点开始一次向上（走向父节点）调用m函数

// sb删除节点可以不做平衡性的调整
// 仅在加入节点的时候做平衡性调整

// 树结构包含的信息，root，size（这棵树包含的不同节点的数量）
// 结点包含的信息：left，right，size（包含的所在子树的所有不同key的结点）


// 跳表（不是搜索二叉树）==>一大坨单链表